#!/usr/bin/perl

=head1 NAME

Mnet::script::Mnet-test - network automation script

=cut

# Copyright 2006, 2013-2014 Michael J. Menza Jr.
# Refer to `perldoc Mnet` for more information.

=head1 SYNOPSIS

This script allows for regression testing of network automarion
scripts. This type of testing is a practical necessity for scripts
of any complexity that will be used in a production environment.

Usage examples:

 # to create a new test directory for script test outputs
 Mnet-test --test-dir script.tests

 # to create a test scenario directory and .sh script
 Mnet-test --test-dir script.tests \
    --test-create router1-circuit-migration \
    --test-script script.pl --object-name router1 \
    --expect-username jsmith

 # to record scenario session connection and save .test output
 Mnet-test --test-dir script.tests \
    --test-record router1-circuit-migration

 # to accept reviewed scenario .test as as new .accepted output
 Mnet-test --test-dir script.test \
    --test-accept router1-circuit-migration

 # changes to test script might be made here...

 # to replay a test scenario and save new .test output
 Mnet-test --test-dir script.test \
    --test-replay router1-circuit-migration

 # to output .diff between scenario .accepted and .test outputs
 Mnet-test --test-dir script.test \
    --test-diff router1-circuit-migration

 # to replay all test scenarios and output diffs, after changes
 Mnet-test --test-dir script.test --test-replay --test-diff

=head1 DESCRIPTION

The Mnet-test script works with network automation scripts that use
the Mnet::Expect, Mnet::SNMP, and Mnet::Ping modules to record
device connectivity sessions for multiple test scenarios and replay
these sessions to generate new test output, tracking the changes to
these outputs using the system diff utility so that they can be 
reviewed and accepted as correct.

For example, lets say that an automation script named migration.pl
has been created and that this moderately complex script contains
logic to handle 56k and t1 circuit migrations. When this script is
being developed the configurations it creates need to be reviewed
for correctness. Any changes to the script necessitate that outputs
be reviewed again for correctness, to ensure the desired changes
were affected, and nothing unintentional was changed.

In this migration.pl script example, lets say that the some code
common to all circuit types has been created along with the 56k
circuit handling code. At this point the output for 56k circuit
migrations is ready to be reviewed. This is a good time to start
using this test script.

First a directory should be created to hold all the test output
data for this migration.pl script:

 Mnet-test --test-dir ~/migration.tests

This command will create the migration.tests directory in the users
home directory. This directory will be empty except for a default
test diff filter Mnet-test-filter.pl script file. This file can be
ignored for now. The CUSTOMIZING THE TEST DIFF FILTER SCRIPT section
of this document has more information about this file.

Next we need to create a new scenario to test the 56k functionality
of our migration.pl script:

 Mnet-test --test-dir ~/migration.tests \
    --test-create migration-56k \
    --test-script ~/bin/migration.pl \
    --object-name router56k \
    --expect-username jsmith

The --test-create directive above will cause a migration-56k scenario
to be created.  The migration.pl automation script being tested is
specified using the --test-script setting. All other argurments on the
command line will be passed to the test migration.pl script. In this
case the --object-name router56k specifies a current live device that
we can use to record a connectivity session for testing our 56k code.

When --test-create is used to create a new test scenario a subdirectory
is created under the main --test-dir and a .sh file is created in that
subdirectory. The created .sh file is used to run the tested automation
script to record and replay test outputs.

In our migration-56k scenario, the following migration-56.sh script is
created:

 ~/bin/migration.pl --test-scenario migration-56k
    --log-diff --log-stderr 0 --log-summary 0
    --data-dir ~/migration.tests/migration-56k
    --test-dir ~/migration.tests
    --test-script ~/bin/migration.pl
    --object-name router56k

If you were to execute this file it would run the migration.pl script
and would initiate a session to the router56k device on the network,
prompting you for authentication. The log settings ensure optimal
output for the diff utility, removing timestamps that change and
duplicate log and error entries. The --data-dir setting ensures that
any Mnet data files are saved in the migration-56k scenario directory.

When the Mnet-test --test-record and --test-replay directives are
used the .sh scripts created with the ---test-create directive will
have arguments added to handle recording or replaying Mnet::Expect,
Mnet::SNMP, and Mnet::Ping sessions. These modifications are detailed
in the TEST SCRIPT CONFIGURATION MODIFICATIONS section of this
document.

When the Mnet-test --test-record and --test-replay directives are
used the outputs are displayed to standard output for review and are
also saves in scenario filtered .test output and unfiltered .raw
output files. The filtered .test files are used for diff operations.
The .raw files may be reviewed as necessary for debugging purposes.

The --test-record directive is normally used after the --test-create
directive has created a new scenario .sh file. The --test-record
directive will execute a scenario .sh file with several arguments
appended to automatically record any Mnet::Expect, Mnet::SNMP, and
Mnet::Ping session activity so that outputs may be generated later
without having to reconnect to devices on the network. This is the
real value of the Mnet-test framework - the ability to quickly and
repeatedly run tests for network automation scripts without needing
to connect to devices on the network all of the time.

The command to record connectivity session data for our 56k
migration script scenario is:

 Mnet-test --test-dir ~/migration.tests \
    --test-record migration-56k 

This will result in the migration-56k.sh script being executed with
the --expect-record, --snmp-record, and --ping-record arguments
appended. Session activity from these Mnet modules will be recorded
in .expect, .snmp, and .ping files in the migration-56k directory.

Filtered output from the migration.pl script execution will be saved
in a migration-56k.test file. This is the same output that is sent
to the terminal after the above Mnet-test --test-record command is 
issued.

At any point the Mnet-test --test-replay directive may be executed
to create new .test output for a scenario that has already been
created with --test-create and recorded with --test-record. Note 
that --test-record is only necessary for --test-replay to work if
the test script connects to network devices. But all the most
interesting automation scripts do this, right?

After the scenario .test output is reviewed the Mnet-test --test-accept
directive should be used to mark that output as new accepted baseline
output for future test diff output:

 Mnet-test --test-dir ~/migration.tests \
    --test-accept migration-56k

Running this command will result in the current migration-56k.test
file being copied as new migration-56k.accepted file. This should
only be done after the .test file is reviewed for correctness.

Now that we have .accepted baseline output for our migration-56k
scenario we can test future changes we make to the script. Lets
say that we start adding code to handle t1 circuits and we want
to be sure that we do not alter any of our reviewed 56k output
configurations. The following commands can be executed:

 Mnet-test --test-dir ~/migration.tests \
    --test-replay migration-56k

 Mnet-test --test-dir ~/migration.tests \
    --test-diff migration-56k

Or, to save time and do these both at once:

 Mnet-test --test-dir ~/migration.tests \
    --test-replay migration-56k --test-diff

The above will cause a new migration-56k.test to be created, using
--expect-replay, --snmp-replay, and --ping-replay to generate the
output from recorded session files without needing to actually
reconect to the router56k device. That .test output will be displayed
for review, along with a diff highlighting anything different between
this new .test output and the baseline .accepted output.

The above --test-diff commands will also result the creation of a
 migration-56k.diff file in the migration-56k scemnario directory. This
file might come in handy if test output needs to be archived and sent
to someone in bulk for review.

This replay output can be reviewed. In the above example, where we
are adding new t1 code we probably do not expect any changes in the
56k scenario. If we see any changes in the diff we can investigate.

In other situations, such as fixing a problem in the 56k code, we 
may expect changes in the diff. These can be reviewed for correctness
then the new .test output made the new go-forward .accepted baseline
output using the Mnet-test --test-accept directive for migration-56k
scenario.

When we are finished with the t1 code we can use the Mnet-test script
to create, record, review, and accept output for a new migration-t1
scenario, just like we did for the migration-56k scenario above.

When we have multiple scenarios we can run Mnet-test --test-replay
and --test-diff commands for a --test-dir against all scenarios by
leaving the scenario name out:

 Mnet-test --test-dir ~/migrations.test --test-replay
 Mnet-test --test-dir ~/migrations.test --test-diff

Or, for the ultimate in convenience we can get new .test outputs
for all of our scenarios and check for diffs against any of our
baseline .accepted outputs with one command:

 Mnet-test --test-dir ~/migrations.test \
    --test-replay --test-diff

And even better, we can pipe this through grep just to see just the
diff output only, also teeing everything to a .rtf file that be
reviewed in detail, even opening on windows workstations:

 Mnet-test --test-dir ~/migrations.test \
    --test-replay --test-diff \
    2>&1 | tee ~/migrations.rtf | grep '^diff [^ ]\+:'

Taken all together this allows for offline regression testing of an
automation script as it is being developed or modified to ensure that
nothing is being unintentionally changed that affects previously
validated script outputs.

=head1 CONFIGURATION

Alphabetical list of config settings supported by this script:

 --test-dir <test-dir>      required location of test scenario data

 --test-create <scenario>   create scenario shell script using all args
 --test-script <script>     target script path, --test-create requires

 --test-record <scenario>   scenario session recording and test output

 --test-accept <scenario>   accept test output as baseline for scenario
 --test-accept              accept test outputs for all scenarios

 --test-replay <scenario>   test output from scenario script replay
 --test-replay              test output from all scenario script replays

 --test-diff <scenario>     diff scenario accepted and test outputs
 --test-diff                diff all scenario accepted and test outputs

 --test-noreconfig          default enable test config modifications
 --test-diff-command <cmd>  defaults to diff
 --test-diff-filter <file>  default Mnet-test-filter.pl

 --test-scenario <scenario> set in scenario shell script for reference

 --main-version             set at compilation to build number 

Note that the test-script setting is required with the test-create
directive. The test-script setting needs to contain a valid absolute
path to the target script executable, unless the target script is in
a directory listed in the shell path environment variable.

Refer to the documentation for the Mnet module for a complete list
of configuration options.

=head1 TEST SCRIPT CONFIGURATION MODIFICATIONS

Note that when the --test-create argument is used to create a test
scenario .sh script all other command line arguments will be sent to
the specified target --test-script. This allows for the target
device --mnet-object and other paramters to be specified for the
target test automation script.

Also note that the Mnet-test directives will add and/or remove the
following configuration options when running the --test-script as
long as test --test-noreconfig setting is not set:

 --expect-record            added when --test-record is used
 --ping-record              added when --test-record is used
 --snmp-record              added when --test-record is used

 --conf-noinput             added when --test-replay is used
 --expect-replay            added when --test-replay is used
 --ping-replay              added when --test-replay is used
 --snmp-replay              added when --test-replay is used

The following settings are always added by the test-create directive,
even if the test-no-reconfig opetion is set:

 --data-dir                 set to test-dir/test-scenario path

 --log-diff                 always added
 --log-stderr 0             always added
 --log-summary 0            always added

These configuration modifications are handled in the scenario .sh
file that is created under each test scenario directory. The mbove
settings ay be overridden by --test-create command line arguments
that would be appended to a scenario .sh file.

=head1 CUSTOMIZING THE TEST DIFF FILTER SCRIPT

The --test-diff-filter script file handles filtering out differences
between --test-record and --test-replay outputs that need to be
ignored.

The default --test-diff-filter script, named Mnet-test-filter.pl,
is created in the configured --test-dir if it is not present. This
default filter script handles filtering the typical Mnet outputs
known to create spurious record/replay diff outputs, such as from
the Mnet::Expect, Mnet::SNMP, and Mnet::Ping modules.

It is considered an adavnced usage to need to modify the default
filter script for testing of a target automation script. This may 
be necessary if diff output is occuring in test outputs and it is
determined that this diff output should be suppressed.

It is recommended that the existing --test-diff-filter script be
used to create any customized filtering script. The structure of
the filter script is such that an $input string is passed to it
containing all output lines, and an $output string is built by
looping through the input lines and applying any necessary
filtering. The default filter script modifies some lines such
as record and replay configuration arguments, and skips some
lines such as expect and snmp session details that would differ
for record and replay sessions.

Care needs to be taken that any output that is filtered does not
cause other important test output to be suppressed. It is recommended
that added filters be as specific as possible to avoid this problem.

=head1 OTHER NOTES AND ADVANCED MODIFICATIONS

Note that automation script output needs to be consistent for testing
to work. This means that hash keys may need to be sorted to ensure
that they are processed in a consistant order.

For certain advanced automation scripts it may be necessary to make
other modifications to use the Mnet-test framework.

The default scenario .sh script made by the --test-create directive
has the --test-create parameter in the command line. When --test-record
or --test-replay is executed any and all instances of the --test-create
parameter are changed to --test-record or --test-replay before running
the .sh command line which calls the target test automation script. 

The test automation script can check the --test-record and --test-replay
configuration settings and modify its behavior accordingly. This allows
for customized control over these test phases, ordinarily to ensure
that output is normalized for the diff comparisons.

Some other Mnet-test parameters are available in the test automation
scripts, such as --test-scenario, --test-dir, and --test-script. These
can be examined and script behavior modified.

A common situation is when device session commands are added which 
can inavlidate previous session recordings, those which do not contain
the new session commands. In this situation new session recordings
need to be made, the script modified to skip these for test scenarios
that are missing these recorded commands, or the script failure errors
accepted in the new replay outputs.

=cut

# use modules
use warnings;
use strict;
use File::Path;
use Mnet;


# read object
our $cfg = &config({
    'main-version'      => '+++VERSION+++',
    'test-diff-command' => 'diff',
    'test-diff-filter'  => 'Mnet-test-filter.pl',
});

# log that we are starting
&inf("test starting");

# check required test-dir arg
die "required test-dir is not set\n" if not $cfg->{'test-dir'};
die "test-dir should not contain spaces\n" if $cfg->{'test-dir'} =~ /\s/;

# init diff filter code variable
my $diff_filter_code = undef;

# read diff filter code from file, will be created if it doesn't exist
if ($cfg->{'test-create'}
    or not ($cfg->{'test-accept'} or $cfg->{'test-diff'}
    or $cfg->{'test-record'} or $cfg->{'test-replay'})) {
    $diff_filter_code = &diff_filter_read;
    &diff_filter_create if not $diff_filter_code;
    exit if not $cfg->{'test-create'};
    $diff_filter_code = &diff_filter_read;
} else {
    $diff_filter_code = &diff_filter_read;
}

# output error if unable to initialize diff filter code
die "missing diff_filter_code\n" if not $diff_filter_code;
&dtl("diff_filter_code = $_") foreach split(/\n/, $diff_filter_code);

# ensure that one, and only one, of the test directives are specified
if (not ($cfg->{'test-create'} xor $cfg->{'test-record'}
    xor $cfg->{'test-replay'} xor $cfg->{'test-diff'}
    xor ($cfg->{'test-replay'} and $cfg->{'test-diff'})
    xor $cfg->{'test-accept'})) {
    die "invalid test directive, must be one of test-create, test-record, "
        . "test-replay, test-accept, test-diff, or test-replay and test-diff\n";
}

# output error if unable to initialize diff filter code
die "missing diff_filter_code\n" if not $diff_filter_code;
&dtl("diff_filter_code = $_") foreach split(/\n/, $diff_filter_code);

# create scenario shell script with command line args
if ($cfg->{'test-create'}) {
    die "test-create scenario sname should not contain spaces"
        if $cfg->{'test-create'} =~ /\s/;
    &inf("test-create $cfg->{'test-dir'}/$cfg->{'test-create'}");
    &create_scenario($cfg->{'test-create'});

# execute scenario shell script, record output
} elsif ($cfg->{'test-record'}) {
    die "test-record scenario sname should not contain spaces"
        if $cfg->{'test-record'} =~ /\s/;
    &inf("test-record $cfg->{'test-dir'}/$cfg->{'test-record'}");
    syswrite STDOUT, "\n";
    &record_scenario($cfg->{'test-record'});

# replay all scenario shell scripts
} elsif ($cfg->{'test-replay'} and $cfg->{'test-replay'} eq '1') {
    &inf("test-replay all test-dir $cfg->{'test-dir'} scenarios");
    opendir(my $dh, $cfg->{'test-dir'})
        or die "test-dir open error $cfg->{'test-dir'} $!\n";
    my $count = 0;
    syswrite STDOUT, "\n";
    foreach my $scenario (readdir($dh)) {
        next if $scenario eq '.' or $scenario eq '..';
        next if not -d "$cfg->{'test-dir'}/$scenario";
        $count++;
        &replay_scenario($scenario);
        &diff_scenario($scenario) if $cfg->{'test-diff'};
    }
    close $dh;
    die "test-replay no scenarios found in test-dir $cfg->{'test-dir'}\n"
        if not $count;

# replay scenario shell script
} elsif ($cfg->{'test-replay'}) {
    die "test-replay scenario sname should not contain spaces"
        if $cfg->{'test-replay'} =~ /\s/;
    &inf("test-replay $cfg->{'test-dir'}/$cfg->{'test-replay'}");
    syswrite STDOUT, "\n";
    &replay_scenario($cfg->{'test-replay'});
    &diff_scenario($cfg->{'test-diff'}) if $cfg->{'test-diff'};

# diff output for all scenarios
} elsif ($cfg->{'test-diff'} and $cfg->{'test-diff'} eq '1') {
    &inf("test-diff all test-dir $cfg->{'test-dir'} scenarios");
    opendir(my $dh, $cfg->{'test-dir'})
        or die "test-dir open error $cfg->{'test-dir'} $!\n";
    my $count = 0;
    syswrite STDOUT, "\n";
    foreach my $scenario (readdir($dh)) {
        next if $scenario eq '.' or $scenario eq '..';
        next if not -d "$cfg->{'test-dir'}/$scenario";
        $count++;
        &diff_scenario($scenario);
    }
    close $dh;
    die "test-diff no scenarios found in test-dir $cfg->{'test-dir'}\n"
        if not $count;

# diff output for a specified scenario
} elsif ($cfg->{'test-diff'}) {
    die "test-diff scenario sname should not contain spaces"
        if $cfg->{'test-diff'} =~ /\s/;
    &inf("test-diff $cfg->{'test-dir'}/$cfg->{'test-diff'}");
    syswrite STDOUT, "\n";
    &diff_scenario($cfg->{'test-diff'});

# accept new output for all scenarios
} elsif ($cfg->{'test-accept'} and $cfg->{'test-accept'} eq '1') {
    &inf("test-accept all test-dir $cfg->{'test-dir'} scenarios");
    opendir(my $dh, $cfg->{'test-dir'})
        or die "test-dir open error $cfg->{'test-dir'} $!\n";
    my $count = 0;
    foreach my $scenario (readdir($dh)) {
        next if $scenario eq '.' or $scenario eq '..';
        next if not -d "$cfg->{'test-dir'}/$scenario";
        $count++;
        &accept_scenario($scenario);
    }
    close $dh;
    die "test-accept no scenarios found in test-dir $cfg->{'test-dir'}\n"
        if not $count;

# accept new output for specified scenario
} elsif ($cfg->{'test-accept'}) {
    die "test-accept scenario sname should not contain spaces"
        if $cfg->{'test-accept'} =~ /\s/;
    &inf("test-accept $cfg->{'test-dir'}/$cfg->{'test-accept'}");
    &accept_scenario($cfg->{'test-accept'});

# output an error for unprocessed test directive
} else {
    die "no test directive processed\n";
}

# log that we are done
&inf("test finished");

# finished
exit;



sub accept_scenario {

# internal: &accept_scenario($scenario);
# purpose: process accept scenario directive

    # read input scenario name
    my $scenario = shift or die "missing scenario arg";

    # set file names of test and accepted files, and init contents
    my $test_file = "$cfg->{'test-dir'}/$scenario/$scenario.test";
    my $accepted_file = "$cfg->{'test-dir'}/$scenario/$scenario.accepted";
    my ($test_text, $accepted_text) = ("", "");

    # read scenario .test file, ensure that it is not empty
    open(my $fh1, $test_file) or die "$test_file read open error $!\n";
    while (<$fh1>) {
        chomp(my $line = $_);
        $test_text .= "$line\n";
    }
    close $fh1;
    die "cannot accept empty $test_file\n" if $test_text !~ /\S/;

    # read scenario .accepted file if it exists
    if (-f $accepted_file) {
        open(my $fh2, $accepted_file)
            or die "$accepted_file read open error $!\n";
        while (<$fh2>) {
            chomp(my $line = $_);
            $accepted_text .= "$line\n";
        }
        close $fh2;
    }

    # skip update if new .test and already .accepted outputs already match
    if ($accepted_text eq $test_text) {
        &dbg("skipped identical $scenario .accepted and .test outputs");

    # update .accepted with .test, .accepted missing or new .test is different
    } else {
        open(my $fh, ">$accepted_file")
            or die "$accepted_file write open error $!\n";
        print $fh $test_text;
        close $fh;
        if (not $accepted_text) {
            &inf("updated missing $scenario.accepted from .test output");
        } else {
            &inf("updated $scenario.accepted from different .test output");
        }
    }

    # finished accept_scenario function
    return;
}



sub create_dir {

# internal &create_dir($dir)
# purpose: creates and changes into specified directory, or exit with error

    # read directory input arg
    my $dir = shift or die "missing dir arg";

    # attempt to create directory if it does not exist
    if (!-d $dir) {
        &inf("creating missing directory $dir");
        eval { mkpath($dir) };
        die "error creating directory $dir $@\n" if $@;
        die "error verifing creation of directory $dir\n" if !-d $dir;
    }

    # finished create_dir function
    return;
}



sub create_scenario {

# internal: &create_scenario($scenario);
# purpose: process create scenario directive

    # read input scenario name
    my $scenario = shift or die "missing scenario arg";

    # check required test-script is set if test-create is specified
    die "test-script is required with test-create set\n"
        if not $cfg->{'test-script'};

    # attempt to chdir into scenario directory
    &create_dir("$cfg->{'test-dir'}/$scenario");

    # init scenario .sh script, $1 will be --test-record or --test-replay
    my $cmd_line = "$cfg->{'test-script'} ";
    $cmd_line .= "--test-scenario $cfg->{'test-create'}";
    $cmd_line .= " --log-diff --log-stderr 0 --log-summary 0";
    $cmd_line .= " --data-dir $cfg->{'test-dir'}/$scenario";

    # copy command line args to output, nullify data-dir if not test-noreconfig
    foreach my $arg (@ARGV) {
        if ($arg !~ /\s/) {
            $cmd_line .= " $arg";
        } else {
            $arg =~ s/'/\\'/g;
            $cmd_line .= " '$arg'";
        }
    }

    # remove test-create arg and param
    $cmd_line =~ s/(\s--test-create)\s+'?\S+'?/$1/;

    # debug output of command line going into target scenario shell script
    &inf("test-create cmd_line = $cmd_line");

    # create scenario shell file
    my $scenario_sh = "$cfg->{'test-dir'}/$scenario/$scenario.sh";
    open(my $fh, ">$scenario_sh")
        or die "test-create write open $scenario_sh error, $!\n";
    print $fh "$cmd_line\n";
    close $fh;

    # finished create_scenario function
    &inf("test-create finished $scenario_sh");
    return;
}



sub diff_filter_create {

# internal: &diff_filter_create;
# purpose: create diff filter file

    # ensure that test-dir exists
    &create_dir($cfg->{'test-dir'});

    # set name for diff filter file in test directory
    my $file = "$cfg->{'test-dir'}/$cfg->{'test-diff-filter'}";

    # set default code for diff filter
    my $diff_filter_code = '

    # initialize output
    $output = "";

    # loop through all lines in input
    foreach my $l (split(/\n/, $input)) {

        # reset test record/replay cfg
        $l =~ s/test-(record|replay)/test-record|test-replay/
            if $l =~ /^dbg 7 \S+ mnet config setting test-(record|replay) =/;

        # skip expect input, dtl, inf, and most dbg, reset record/replay cfgs
        next if $l =~ /^(Enter|Verify)(\s+\S+)?\s+expect-\S+:/;
        next if $l =~ /^dtl 7 \S+ expect /;
        next if $l =~ /^inf 6 \S+ expect /;
        next if $l =~ /^dbg 7 \S+ expect /
            and $l !~ /^dbg 7 \S+ expect command .+ (timeout|returned) /;
        $l =~ s/expect-(record|replay)/expect-record|expect-replay/
            if $l =~ /^dbg 7 \S+ mnet config setting expect-(record|replay) =/;

        # skip mnet dbg, input verify error, dtl messages, and conf-noinput
        next if $l =~ /^dbg 7 \S+ mnet creating missing data-dir dir/;
        next if $l =~ /^dbg 7 \S+ mnet input \S+ \S+ from terminal/;
        next if $l =~ /^\QVerification error...!\E$/;
        next if $l =~ /^dtl 7 \S+ mnet /;
        next if $l =~ /^dbg 7 \S+ mnet config setting conf-noinput =/;

        # skip ping dtl messages, reset record/replay cfg
        next if $l =~ /^dtl 7 \S+ ping /;
        $l =~ s/ping-(record|replay)/ping-record|ping-replay/
            if $l =~ /^dbg 7 \S+ mnet config setting ping-(record|replay) =/;

        # skip snmp input and dtl messages, reset record and replay cfgs
        next if $l =~ /^(Enter|Verify)(\s+\S+)?\s+snmp-community:/;
        next if $l =~ /^dtl 7 \S+ snmp /;
        $l =~ s/snmp-(record|replay)/snmp-record|snmp-replay/
            if $l =~ /^dbg 7 \S+ snmp \S+ snmp-(record|replay)/;
        $l =~ s/snmp-(record|replay)/snmp-record|snmp-replay/
            if $l =~ /^dbg 7 \S+ mnet config setting snmp-(record|replay) =/;

        # append line to output
        $output .= "$l\n";
    }
    ';

    # save diff filter file
    &inf("creating diff filter file $file");
    open(my $fh, ">$file") or die "diff filter file $file write error, $!\n";
    foreach my $line (split(/\n/, $diff_filter_code)) {
        $line =~ s/^\s\s\s\s//;
        print $fh "$line\n";
    }
    close $fh;

    # finished diff_filter_create function
    return;
}



sub diff_filter_execute {

# internal: $output = &diff_filter_execute($input);
# purpose: run input through diff filter code

    # read input 
    my $input = shift;
    die "missing input arg" if not defined $input;

    # initialize output
    my $output = "";

    # evaluate diff_filter_code, it loops through input and builds output
    my $result = eval($diff_filter_code);

    # check for errors from diff filter code execution
    my $file = "$cfg->{'test-dir'}/$cfg->{'test-diff-filter'}";
    die "diff_filter_execute $file error, $@" if not defined $result or $@;
    die "diff_filter_execute no output" if not $output;

    # finished diff_filter_execute function
    return $output;
}



sub diff_filter_read {

# internal: $diff_filter_code = &diff_filter_read;
# purpose: read diff filter file from test-dir, or return undefined

    # initialize output diff filter code
    my $diff_filter_code = undef;

    # set name for diff filter file in test directory
    my $file = "$cfg->{'test-dir'}/$cfg->{'test-diff-filter'}";

    # read diff filter code file if it exists
    if (-e $file) {
        &inf("found diff filter file $file");
        open(my $fh, $file) or die "diff filter file $file open error, $!\n";
        $diff_filter_code .= "$_\n" while <$fh>;
        close $fh;
    }

    # finished diff_filter_read function
    return $diff_filter_code;
}



sub diff_scenario {

# internal: &diff_scenario($scenario);
# purpose: process diff scenario directive

    # read input scenario name
    my $scenario = shift or die "missing scenario arg";

    # set file names of test and accepted files
    my $test_file = "$cfg->{'test-dir'}/$scenario/$scenario.test";
    my $accepted_file = "$cfg->{'test-dir'}/$scenario/$scenario.accepted";
    my $diff_file = "$cfg->{'test-dir'}/$scenario/$scenario.diff";

    # erase any old diff file
    die "$diff_file could not be deleted, $!"
        if -f $diff_file and not unlink $diff_file;

    # output error if .test or .accepted files do not exist
    die "$test_file error no such file\n" if not -f $test_file;
    die "$accepted_file error no such file\n" if not -f $accepted_file;

    # output error if .test or .accepted files are empty
    die "cannot accept empty $test_file\n" if -z $test_file;
    die "cannot accept empty $accepted_file\n" if -z $accepted_file;

    # execute diff command
    my $diff_cmd = "$cfg->{'test-diff-command'} $accepted_file $test_file";
    my $diff_out = `( $diff_cmd ) 2>&1`;

    # output if diff output shows identical
    if ($diff_out !~ /\S/) {
        syswrite STDOUT, "diff identical, $scenario.accepted = $scenario.test\n";

    # output diff lines to diff file and to terminal
    } else {
        open(my $fh, ">$diff_file") or die "$diff_file write open error $!\n";
        print $fh "diff $scenario: $diff_cmd\n";
        syswrite STDOUT, "diff $scenario: cmd = $diff_cmd\n";
        foreach my $line (split(/\n/, $diff_out)) {
            print $fh "diff $scenario: $line\n";
            syswrite STDOUT, "diff $scenario: $line\n";
        }
        close $fh;
    }

    # finished diff output
    syswrite STDOUT, "\n";

    # finished diff_scenario function
    return;
}



sub record_scenario {

# internal: &record_scenario($scenario);
# purpose: process record scenario directive

    # read input scenario name
    my $scenario = shift or die "missing scenario arg";

    # read scenario .sh command line
    my $cmd_line = '';
    my $scenario_sh = "$cfg->{'test-dir'}/$scenario/$scenario.sh";
    open(my $fh1, "$scenario_sh") or die "$scenario_sh read open error $!\n";
    $cmd_line .= "$_\n" while <$fh1>;
    close $fh1;

    # add necessary config statements, unless test-noreconfig set for scenario
    if ($cmd_line !~ /(^|\s)--test-noreconfig(\s|$)/) {
        my $expect = "--expect-record $scenario.expect";
        my $snmp = "--snmp-record $scenario.snmp";
        $cmd_line =~ s/--/$expect $snmp --ping-record --/;
    }

    # replace test-create with test-record
    $cmd_line =~ s/\s--test-create(\s|$)/ --test-record$1/g;

    # capture output from scenario shell command
    my $raw_file = "$cfg->{'test-dir'}/$scenario/$scenario.raw";
    &inf("test-record cmd_line = $_") foreach split(/\n/, $cmd_line);
    system("( $cmd_line ) 2>&1 | tee $raw_file");
    syswrite STDOUT, "\n";

    # read scenario raw file
    my $raw_text = "";
    open(my $fh2, "$raw_file")
        or die "$raw_file open error $!\n";
    while (<$fh2>) {
        chomp(my $line = $_);
        $raw_text .= "$line\n";
    }
    close $fh2;

    # filter raw file
    my $out = &diff_filter_execute($raw_text);
    chomp($out);

    # save scenario record output as new scenario test output
    my $scenario_test = "$cfg->{'test-dir'}/$scenario/$scenario.test";
    open(my $fh3, ">$scenario_test")
        or die "$scenario_test write open error $!\n";
    print $fh3 "$out\n";
    close $fh3;

    # finished record_scenario function
    return;
}



sub replay_scenario {

# internal: &replay_scenario($scenario);
# purpose: process replay scenario directive

    # read input scenario name
    my $scenario = shift or die "missing scenario arg";

    # read scenario .sh command line
    my $cmd_line = '';
    my $scenario_sh = "$cfg->{'test-dir'}/$scenario/$scenario.sh";
    open(my $fh1, "$scenario_sh") or die "$scenario_sh read open error $!\n";
    $cmd_line .= "$_\n" while <$fh1>;
    close $fh1;

    # add necessary config statements, unless test-noreconfig set for scenario
    if ($cmd_line !~ /(^|\s)--test-noreconfig(\s|$)/) {
        my $expect = "--expect-replay $scenario.expect";
        my $snmp = "--snmp-replay $scenario.snmp";
        $cmd_line =~ s/--/$expect $snmp --ping-replay --conf-noinput --/;
    }

    # replace test-create with test-replay
    $cmd_line =~ s/\s--test-create(\s|$)/ --test-replay$1/g;

    # capture output from scenario shell command
    my $raw_file = "$cfg->{'test-dir'}/$scenario/$scenario.raw";
    &inf("test-replay cmd_line = $_") foreach split(/\n/, $cmd_line);
    system("( $cmd_line ) 2>&1 | tee $raw_file");
    syswrite STDOUT, "\n";

    # read scenario raw file
    my $raw_text = "";
    open(my $fh2, "$raw_file")
        or die "$raw_file open error $!\n";
    while (<$fh2>) {
        chomp(my $line = $_);
        $raw_text .= "$line\n";
    }
    close $fh2;

    # filter raw file
    my $out = &diff_filter_execute($raw_text);
    chomp($out);

    # save scenario record output as new scenario test output
    my $scenario_test = "$cfg->{'test-dir'}/$scenario/$scenario.test";
    open(my $fh3, ">$scenario_test")
        or die "$scenario_test write open error $!\n";
    print $fh3 "$out\n";
    close $fh3;

    # finished replay_scenario function
    return;
}



=head1 COPYRIGHT AND LICENSE

Copyright 2006, 2013-2014 Michael J. Menza Jr.
Refer to `perldoc Mnet` for more information.

=head1 SEE ALSO

Mnet

=cut

