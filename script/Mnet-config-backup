#!/usr/bin/perl

=head1 NAME

Mnet::script::Mnet-config-backup - network automation script

=cut

# Copyright 2006, 2013-2014 Michael J. Menza Jr.
# Refer to `perldoc Mnet` for more information.

=head1 SYNOPSIS

Usage example:

 Mnet-config-backup \
    --batch-list /etc/hosts --batch-hosts \
    --data-dir /data/dir \
    --expect-username cisco --expect-enable \
    2>&1 | tee Mnet-config-backup.log

=head1 DESCRIPTION

This script used the Mnet perl modules to backup the configuration
of one or more objects.

The batch-list and batch-hosts arguments will instruct the script to
connect to all entries in the system /etc/hosts file for the config
backups. Alternatively the object-name and/or object-address arguments
can be used to process a single device.

The expect-username can be set on the command line, instead of being
prompted for when the script starts. The expect-password used for
usermode login and the expect-enable password will be prompted for
when the script runs.

There is a default config-show option set to 'show running-config'.
This will work for all cisco and cisco-like devices.

Note that all log entries are saved to a database if db-name is set.
Also note that all debug log entries are saved in an .err file for a
device if the script exits with an error while processing an object.

Refer to the Mnet::script::Mnet-web-mojo script for displaying output
data from the data-dir directory or the db-name log database.

=head1 CONFIGURATION

Alphabetical list of config settings supported by this script:

 --object-address <addr>       specify address of one object to config
 --object-name <name>          specify name of one object to config
 --batch-list <file>           specify list of objects and addresses
 --batch-hosts                 batch file will be in hosts file format
 --data-dir <directory>        directory for log and error storage

 --expect-username <user>      login user or null, default prompts
 --expect-password <pass>      specify password, default will prompt
 --expect-enable <1|pass>      set 1 for prompt, default disabled

 --config-backup-days <days>   default keeps 100 days of backups
 --config-backup-prefix <txt>  default config-backup as file prefix
 --config-backup-skip          set to skip processing by this scrip

 --config-show <command>       default 'show running-config' for cisco

Refer to the documentation for the Mnet and Mnet::Expect modules for
a complete list of configuration options.

=cut

# use modules
use warnings;
use strict;
use File::Copy;
use Mnet;
use Mnet::Expect;
use Time::Local;

# read object
our $cfg = &object({
    'config-show'          => 'show running-config',
    'config-backup-days'   => 100,
    'config-backup-prefix' => 'config-backup',
    'main-version'         => '+++VERSION+++',
});

# exit if skip directive is set
if ($cfg->{'config-backup-skip'}) {
    &inf("exit early, config-backup-skip is set");
    exit;
}

# exit if data directory is not set
if (not $cfg->{'data-dir'}) {
    die "cannot backup config, data-dir directory is not set\n";
    exit;
}

# open session to object
&dbg("opening expect session to current object-name");
my $session = new Mnet::Expect or die "could not connect to device\n";

# retrieve a copy of the running config
&dbg("retrieving config_current from current object-name");
my $config_current = $session->command($cfg->{'config-show'});
die "unable to retrieve current config\n" if not defined $config_current;

# retrieve name of current backup config file, exit if unable to open directory
my $file_latest = undef;
if (opendir(my $dh, '.')) {
    &dbg("looking for file_latest in data-dir directory");
    my @files = sort(readdir($dh));
    close $dh;
    my $prefix = $cfg->{'config-backup-prefix'};
    foreach my $file (@files) {
        next if $file !~ /^$prefix\E_\d\d\d\d-\d\d-\d\d\.cfg$/;
        $file_latest = $file;
        &dbg("found file_latest $file_latest");
        last;
    }
} else {
    die "unable to open mnet-dir $cfg->{'data-dir'} for .cfg, $!";
}

# read contents of the most recent backed up config
my $config_latest = undef;
if (not $file_latest) {
    &dbg("skipping config_latest read, does not exist");
} elsif (open(my $fh, $file_latest)) {
    &dbg("reading config_latest contents from $file_latest");
    $config_latest .= $_ while <$fh>;
    close $fh;
    &dbg("finished reading config_latest from $file_latest");
} else {
    die "unable to open file_latest for reading $file_latest, $!";
} 

# filter the current and latest backup config, removing ever-changing bits
&dbg("calling filter_config for config_current");
my $config_current_filtered =  &filter_config($config_current, "current");
&dbg("calling filter_config for config_latest");
my $config_latest_filtered = &filter_config($config_latest, "backup");

# exit if filtered current running config is the same as latest backup config
if (defined $config_latest_filtered
    and $config_current_filtered eq $config_latest_filtered) {
    &inf("config-backup finished, config unchanged");
    exit;
}

# set base filename for writing new currnet config
my $base_current = "$cfg->{'config-backup-prefix'}_" . &date_time2file(time);

# copy the latest backup config to .old before clobbering it with new config
if (-e "${base_current}.cfg") {
    &dbg("copying ${base_current}.cfg to ${base_current}.old");
    copy("${base_current}.cfg", "${base_current}.old")
        or die "copy ${base_current}.cfg to ${base_current}.old failed, $!\n";
    &dbg("finished copying ${base_current}.cfg to ${base_current}.old");
}

# save current config as the new backup
if (open(my $fh, ">${base_current}.new")) {
    &dbg("writing config_current to ${base_current}.new");
    syswrite $fh, $config_current;
    close $fh;
    &dbg("finished writing config_current to ${base_current}.new");
    rename "${base_current}.new", "${base_current}.cfg"
        or die "unable to rename ${base_current}.new, $!\n";
    &dbg("renamed ${base_current}.new to ${base_current}.cfg");
} else {
    die "unable to open ${base_current}.new for writing, $!\n";
}

# delete .old configs older than config-backup-days days old
if (opendir(my $dh, '.')) {
    &dbg("looking for .old configs in data-dir directory");
    my @files = sort(readdir($dh));
    close $dh;
    my $prefix = $cfg->{'config-backup-prefix'};
    foreach my $file (@files) {
        next if $file !~ /^$prefix\E_(\d\d\d\d-\d\d-\d\d)\.old$/;
        my $file_time = &date_file2time($1);
        my $days_old = int(( time - $file_time ) / 86400);
        &dtl("found .old config $file, $days_old, $file_time");
        if ($days_old > $cfg->{'config-backup-days'}) {
            unlink $file or die "could not delete old $file, $!";
        }
    }
    &dbg("finished looking for .old configs in data-dir directory");
} else {
    die "unable to open mnet-dir $cfg->{'data-dir'} for .old, $!";
}

# log that we are done
&inf("config-backup finished");

# finished
exit;



sub date_file2time {

# internal: $unix_time = &file2time($file_date)
# purpose: convert input yyyy-mm-dd to unix time format

    # read input time
    my $file_date = shift or die "missing file_time arg";

    # validate file_date is in correct format and parse
    die "file_date not in correct yyyy-mm-dd format"
        if $file_date !~ /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
    my ($year, $mon, $mday) = ($1, $2, $3);

    # adjust month
    $mon--;

    # convert to unix time, clear $sec, $min, $hour
    my $unix_time = timelocal(0, 0, 0, $mday, $mon, $year);

    # finished
    return $unix_time;
}



sub date_time2file {

# internal: $file_date = &time2file($unix_time)
# purpose: convert input unix time to yyyy-mm-dd format

    # read input time
    my $unix_time = shift or die "missing unix_time arg";

    # get sec, min, hour, mday, mon, year, wday, yday, isdst from input time
    my ($s,$m,$h,$mday,$mon,$year,$w,$y,$i) = localtime($unix_time);

    # fix year and month
    $year += 1900;
    $mon++;

    # convert to string used as date in config backup filenames
    my $file_date = sprintf("%04d-%02d-%02d", $year, $mon, $mday);
    
    # finished
    return $file_date;
}



sub filter_config {

# internal: $output = &filter_config($input)
# purpose: filter any parts of config that change and should be ignored
# $input: input unfiltered config text
# $output: output filtered config text, used for comparisons

    # read input config, return for undefined
    my ($input, $name) = @_;
    die "filter_config missing name arg" if not $name;
    if (not defined $input) {
        &dbg("filter_config skipped for undefined input");
        return undef;
    } 

    # output unfiltered config
    &dtl("$name, nofilter: $_") foreach split(/\n/, $input);

    # initialize output config from input
    &dbg("filter_config initializing");
    my $output = $input;

    # filter a couple of things in ios configs
    $output =~ s/^current configuration.+bytes//gmi;
    $output =~ s/^ntp clock-period \d+/ntp clock-period ??/gmi;

    # output filtered config
    &dtl("$name, filtered: $_") foreach split(/\n/, $output);

    # finished
    &dbg("filter_config finished");
    return $output;
}



=head1 COPYRIGHT AND LICENSE

Copyright 2006, 2013-2014 Michael J. Menza Jr.
Refer to `perldoc Mnet` for more information.

=head1 SEE ALSO

Mnet, Mnet::Expect, Mnet::script::Mnet-web-mojo

=cut

